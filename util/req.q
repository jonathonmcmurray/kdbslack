\d .req

VERBOSE:@[value;`.req.VERBOSE;$[count .z.x;"-verbose" in .z.x;0b]];                 //default to non-verbose output

cookiejar:([host:();path:();name:()] val:();expires:`datetime$();maxage:`long$();secure:`boolean$();httponly:`boolean$();samesite:`$())  //storage for cookies

addcookie:{[h;c]
  /* add or update a cookie in the jar */
  d:(!). "S=;"0:c;                                                                  //parse cookie into dict
  n:string first key d;v:first value d;                                             //extract cookie name & value
  d:lower[key d]!value d;                                                           //make all keys lower case
  r:`host`path`name`val!(".",h;d[`path],"*";n;v);                                   //build up record
  if[`domain in key d;r[`host]:"*.",d`domain];                                      //if domain in cookie, use it for host
  r[`expires]:"Z"$" "sv@[;1 2]" "vs d`expires;                                      //parse expiration date & time
  r[`maxage]:"J"$d`$"max-age";                                                      //TODO calculate expires from maxage
  r[`secure]:`secure in key d;                                                      //check if Secure attribute is set
  r[`httponly]:`httponly in key d;                                                  //check if HttpOnly attribute is set
  r[`samesite]:`$d`samesite;                                                        //check if SameSite attribute is set
  `.req.cookiejar upsert enlist r;                                                  //add cookie to the jar
 }

getcookies:{[pr;h;p]
  /* get cookies that apply for a given protocol, host & path */
  h:".",h;                                                                          //prevent bad tailmatching
  t:select from .req.cookiejar where h like/:host,p like/:path,(expires>.z.t)|null expires;  //select all cookies that apply
  if[not pr~"https://";t:delete from t where secure];                               //delete HTTPS only cookies if not HTTPS request
  :"; "sv"="sv'flip value exec name,val from t;                                     //compile cookies into string
 }

readjar:{[f] /f-file
  /* read a Netscape/cURL format cookiejar */
  j:read0 hsurl f;                                                                  //get hsym of input file & read
  j:j where not ("#"=first'[j])|0=count'[j];                                        //remove comments & empty lines
  t:flip`host`tailmatch`path`secure`expires`name`val!("*S*SJ**";"\t")0:j;           //convert to a table
  t:update host:{"*.",x}'[host] from t where tailmatch=`TRUE;                       //implement tailmatching
  t:update path:{x,"*"}'[path] from t;                                              //implement path matching
  t:update secure:secure=`TRUE from t;                                              //convert secure to boolean
  t:update expires:?[0=expires;0Nz;`datetime$`timestamp$1970.01.01D00+1e9*expires] from t; //calculate expiry
  :delete tailmatch from update httponly:0b,maxage:0Nj,samesite:` from t;           //add extra fields for reQ cookiejar
 }

writejar:{[f;j] /f-file,j-jar
  /* write a Netscape/cURL format cookiejar */
  t :"# Netscape HTTP Cookie File\n";                                               //make file header (copy cURL)
  t,:"# https://curl.haxx.se/docs/http-cookies.html\n";
  t,:"# This file was generated by reQ! Edit at your own risk.\n\n";
  t,:"\n"sv 1_"\t"0:select                                                          //convert to tab delimited & drop headers
       except\:[host;"*"],
       `FALSE`TRUE "*"=first'[host],
       except\:[path;"*"],
       `FALSE`TRUE secure,
       ?[null expires;0;`long$1e-9*(`timestamp$expires)-1970.01.01D0],              //convert expires back to epoch time
       name,
       val 
     from j;
  :hsurl[f] 0: "\n"vs t;                                                            //write to file
  }
  

sturl:{(":"=first x)_x:$[-11=type x;string;]x}                                      //convert URL to string
hsurl:{`$":",sturl x}                                                               //convert URL to hsym

hap:{[x]
  if[x~hsym`$255#"a";'"hsym too long - consider using a string"];                   //error if URL~`: .. too long
  x:sturl x;                                                                        //ensure string URL
  p:x til pn:3+first ss[x;"://"];                                                   //protocol
  uf:("@"in x)&first[ss[x;"@"]]<first ss[pn _ x;"/"];                               //user flag - true if username present
  u:-1_$[uf;(pn _ x) til (un:1+first ss[x;"@"])-pn;""];                             //user:pass
  if[u~"";un:pn];                                                                   //if no user:pass, look for domain after protocol
  d:x til dn:count[x]^first ss[x:un _ x;"/"];                                       //domain
  a:$[dn=count x;enlist"/";dn _ x];                                                 //absolute path
  :(p;u;d;a);                                                                       //return list as .Q.hap
 }

prsu:{hap[y]x}                                                                      //parse URL, return specific component
prot:prsu[0]                                                                        //get protocol from URL
user:prsu[1]                                                                        //get username from URL
host:prsu[2]                                                                        //get hostname from URL
endp:prsu[3]                                                                        //get endpoint from URL
b64encode:{(neg[c] _ .Q.b6 0b sv' 00b,/:6 cut raze (0b vs'`byte$x),(8*c)#0b),(c:neg[count x]mod 3)#"="}
b64decode:{(`char$0b sv'8 cut raze 2_'0b vs'`byte$.Q.b6?x) except "\000"}
def:(!/) flip 2 cut (                                                               //default headers
  "Connection";     "Close";
  "User-Agent";     "kdb+/",string .Q.k;
  "Accept";         "*/*"
 )
ty:@[.h.ty;`form;:;"application/x-www-form-urlencoded"]                             //add type for url encoded form, used for slash commands
ty:@[ty;`json;:;"application/json"]                                                 //add type for JSON (missing in older versions of q)
hu:.h.hug .Q.an,"-.~"                                                               //URI escaping for non-safe chars, RFC-3986

proxy:{[h] /h-host for request
  /* get proxy address if needed for this hostname */
  p:(^/)`$getenv`$(floor\)("HTTP";"NO"),\:"_PROXY";                                 //check HTTP_PROXY & NO_PROXY env vars, upper & lower case - fill so p[0] is http_, p[1] is no_
  t:max(first ":"vs h)like/:{(("."=first x)#"*"),x}each"," vs string p 1;           //check if host is in NO_PROXY env var
  t:not null[first p]|t;                                                            //check if HTTP_PROXY is defined & host isn't in NO_PROXY
  :(t;p 0);                                                                         //return boolean of whether to use proxy & proxy address
 }

headers:{[us;pr;hd;p] /us-username,pr-proxy,hd-custom headers,p-payload
  /* build HTTP headers dictionary */
  d:def,$[count[us]&pr 0;                                                           //username & proxy
           enlist["Proxy-Authorization"]!enlist"Basic ",b64encode[us];              //add proxy-auth header
         count[us];                                                                 //username, no proxy
           enlist["Authorization"]!enlist"Basic ",b64encode[us];                    //add auth header
           ()];                                                                     //no additional header
  if[count p;d["Content-Length"]:string count p];                                   //if payload, add length header
  d,:$[11=type k:key hd;string k;k]!value hd;                                       //get headers dict (convert keys to strings if syms), append to defaults
  :d;
 }

enchd:{[d] /d-dictionary of headers
  /* convert KDB dictionary to HTTP headers */
  k:2_@[k;where 10<>type each k:(" ";`),key d;string];                              //convert non-string keys to strings
  v:2_@[v;where 10<>type each v:(" ";`),value d;string];                            //convert non-string values to strings
  :("\r\n" sv ": " sv/:flip (k;v)),"\r\n\r\n";                                      //encode headers dict to HTTP headers
 }

buildquery:{[m;pr;u;h;d;p] /m-method,pr-proxy,u-url,h-host,d-headers dict,p-payload
  /* construct full HTTP query string */
  r:string[m]," ",$[pr 0;sturl u;endp[u]]," HTTP/1.1\r\n",                          //method & endpoint
       "Host: ",h,$[count d;"\r\n";""],                                             //add host string
       enchd[d],                                                                    //add headers
       $[count p;p;""];                                                             //add payload if present
  :r;                                                                               //return complete query string
 }

formatresp:{[r] /r-raw response
  /* split HTTP response into headers dict & body */
  p:(0,4+first r ss 4#"\r\n") cut r;                                                //split response headers & body
  d:trim enlist[`]_(!/)("S:\n")0:p[0]except"\r";                                    //create dictionary of response headers
  d[`status]:"I"$(" "vs r)1;                                                        //add status code
  :(d;p[1]);                                                                        //return header dict & reponse body
 } 


urlencode:{[d] /d-dictionary
  /* encode a KDB dictionary as a URL encoded string */
  k:key d;v:value d;                                                                //split dictionary into keys & values
  v:enlist each hu each {$[10=type x;x;string x]}'[v];                              //string any values that aren't stringed,escape any chars that need it
  k:enlist each $[all 10=type each k;k;string k];                                   //if keys are strings, string them
  :"&" sv "=" sv' k,'v;                                                             //return urlencoded form of dictionary
 }

urldecode:{[x] /x-urlencoded string
  /* convert a URL encoded string to a KDB dictionary */
  :(!/)"S=&"0:.h.uh ssr[x;"+";" "];                                                 //parse incoming request into dict, replace escaped chars
 }

okstatus:{[v;x] /v-verbose flag,x-reponse (headers;body)
  /* throw a signal if not HTTP OK status */
  if[v|x[0][`status] within 200 299;:x];                                            //if in verbose mode or OK status, return
  'string x[0]`status;                                                              //signal if bad status FIX: handle different status codes - descriptive signals
 }

send:{[m;u;hd;p;v] /m-method,u-url,hd-headers,p-payload,v-verbose flag
  /* build & send HTTP request */
  pr:proxy h:host u;                                                                //check if we need to use proxy & get proxy address
  nu:$[@[value;`.doh.ENABLED;0b];.doh.resolve;]u;                                   //resolve URL via DNS-over-HTTPS if enabled
  hs:hsurl `$prot[nu],host nu;                                                      //get hostname as handle & string
  if[pr[0];hs:hsurl `$prot[pr 1],host pr 1];                                        //overwrite host handle if using proxy
  us:user $[pr 0;pr 1;nu];                                                          //get user name (if present)
  if[count c:getcookies[prot nu;h;endp nu];hd[`Cookie]:c];                          //add any applicable cookies
  d:headers[us;pr;hd;p];                                                            //get dictionary of HTTP headers for request
  r:hs d:buildquery[m;pr;nu;h;d;p];                                                 //build query and execute
  if[v;-1"-- REQUEST --\n",string[hs],"\n",d];                                      //if verbose, log request
  if[v;-1"-- RESPONSE --\n",r];                                                     //if verbose, log response
  r:formatresp r;                                                                   //format response to headers & body
  if[(sc:`$"Set-Cookie") in k:key r 0;                                              //check for Set-Cookie headers
     addcookie[h]'[value[r 0]where k=sc]];                                          //set any cookies necessary
  if[r[0][`status] within 300 399;                                                  //if status is 3XX, redirect FIX: not all 3XX are redirects?
     lo:$["/"=r[0][`Location]0;prot[u],user[u],host[u],r[0]`Location;r[0]`Location]; //detect if relative or absolute redirect
     :.z.s[m;lo;hd;p;v]];                                                           //perform redirections if needed
  :r;
 }

parseresp:{[r]
  /* detect JSON reponse & parse into KDB data structure */
  / TODO - add handling for other data types? /
  :$[(`j in key`)&r[0][`$"Content-Type"]like .h.ty[`json],"*";.j.k;] r[1];          //check for JSON, parse if so
 }

timeout:{[t;m;u;hd;p]
  ot:system"T";system"T ",string t;                                                 //store old timeout & set new
  r:@[0;(`.req.send;m;u;hd;p;VERBOSE);{x}];                                         //send request & trap error
  system"T ",string ot;                                                             //reset timeout
  :$[r~"stop";'"timeout";r];                                                        //return or signal
 }

gb:{(24#"-"),16?.Q.an}                                                              //generate boundary marker
mult:{[b;d] "\r\n" sv mkpt[b]'[string key d;value d],enlist"--",b,"--"}             //build multipart

mkpt:{[b;n;v]
  /* create one part for a multipart form */
  f:-11=type v;                                                                     //check for file
  if[f;t:"Content-Type: ",$[0<count t:.h.ty last ` vs `$.req.sturl v;t;"application/octet-stream"],"\n"];     //get content-type for part
  r :"--",b,"\n";                                                                   //opening boundary
  r,:"Content-Disposition: form-data; name=\"",n,"\"",$[f;"; filename=",1_string v;""],"\n";
  r,:$[f;t;""],"\n",$[f;`char$read1 v;v];                                           //insert file contents or passed value
  :r;
 }

multi:{[d]
  /* covert a q dictionary to a multipart form */
  b:gb[];                                                                           //get boundary value
  m:mult[b;d];                                                                      //make multipart form from dictionary
  :((1#`$"Content-Type")!enlist"multipart/form-data; boundary=",b;m);               //return HTTP header & multipart form
 }

postmulti:{post[x] . multi y}                                                       //send HTTP POST report with multipart form

.req.get:{parseresp okstatus[VERBOSE] send[`GET;x;y;();VERBOSE]}                    //get - projection with no payload & GET method
.req.g:.req.get[;()!()]                                                             //simple get, no custom headers
.req.post:{parseresp okstatus[VERBOSE] send[`POST;x;y;z;VERBOSE]}                   //post - project with POST method
.req.delete:{parseresp okstatus[VERBOSE] send[`DELETE;x;y;z;VERBOSE]}               //delete - project with DELETE method
.req.del:.req.delete[;;()]                                                          //project with no body
.req.d:.req.del[;()!()]                                                             //project with no body or headers

\d .
